define TRANSFER_STATUS (*(u8*)(0xf0002db))
#define TRANSFER_CHECKSUM (*(u8*)(0xf000310))
#define TRANSFER_BYTE_COUNT (*(u8*)(0xf000311))
#define UNKNOWN (*(u8*)(0xf000312))
#define RDR0 (*(u8*)(0x5FFFEC5))
#define TDR0 (*(u8*)(0x5FFFEC3))
#define SSR0 (*(u8*)(0x5FFFEC4))

//from 9800
void loc_9828()
{
   TRANSFER_BYTE_COUNT = 0x80;
   //goto 9794
}

void vectITU3IMIB3()
{
   // interrupt when OE from the drive mech falls
   // PB3 is output enable, PB2 is start strobe
   TSR3 &= 0xFD;
   cd_mech_return_method = 0;
   r1 = cd_mech_bytes & 0x7F;

   if (!(cd_mech_bytes & 0x7F))
   {
      // start of new transfer(loc_97CE)

      // backup register R4-R13, PR, GBR, MACH/MACL
      // save stack to running_task[tcb.saved_sp]
      // set stack to 0xF0008F8
      cd_mech_return_method = 1;

      if (PBDR & 0x4)
         goto loc_9828;
      else
      {
         // 9802
         if (cd_mech_bytes == 0)
         {
            // 980A
            if (byte_F0002CF == 0)
            {
               // 9832
               memset(cd_mech_buff, 0, 11);
               cd_mech_buff[11] = 0xFF;
            }
            else
            {
               // 9832
               memcpy(cd_mech_buff, unk_F0002C4, 12);
               u8 chksum = cd_mech_buff[0];
               for (i = 1; i < 11; i++)
                  chksum = cd_mech_buff[i];
               cd_mech_buff[11] = ~chksum;
               unk_F0002C4[11] = 0;
            }
         }

         // 981E
         TRANSFER_STATUS = 0; // clears rx packet ok flag
         cd_mech_csum2 = 0; // clears csum
      }
   }
   // old transfer
   else if (PBDR & 0x4)
       goto 9768;

   //97ca reset the byte count
   u8 byte_count_temp = 0; //mov #0, r1
 
   //9768
   byte_count_temp++; //add #1, r1
 
   TRANSFER_BYTE_COUNT = byte_count_temp; //mov r1, r0 , mov.b r0, @(0xd, r3)
   
   // Is upcoming data parity byte(number 13 is somewhat deceiving)
   if (byte_count_temp == 13) //cmp/eq #13, r0
   {
      //97ac
      u8 received_data = RDR0;//mov.b @((RDR0 - SMR0), gbr), r0
      received_data = ~received_data; //97ae invert checksum
 
      u8 data_to_transmit;
      //97B2 make sure checksum matches calculated checksum
      if (temp != TRANSFER_CHECKSUM)
      {
         //97c6
         // checksum failure
         data_to_transmit = 1;
      }
      else
      {
         //97b6
         // checksum is good
         TRANSFER_STATUS = 1;
         data_to_transmit = 0;
      }
 
      //97be
      TDR0 = data_to_transmit;
      SSR0 |= 0x40;
   }
   else
   {
      //9776
      u8 to_transmit = cd_mech_buff[cd_mech_bytes-1];//mov r3, r2. add #-1, r2. mov.b @(r0, r2), r0
      TDR0 = to_transmit;//mov.b r0, @((TDR0 - SMR0), gbr)
 
      if (cd_mech_bytes != 1)//cmp/eq #1, r0
      {   //9784
         u8 received_data = RDR0;
         cd_rx_status[cd_mech_bytes-2] = received_data; // even though this is referenced as F0002CE, 
                                                        // it really end up being cd_rx_status since 
                                                        // cd_mech_bytes >= 2
         TRANSFER_CHECKSUM += received_data;
      }
   }
 
   //97be, 9784, 9776 and 9828 all come here
   SSR0 = 0;//9794
 
   if (cd_mech_return_method != 0)//cmp/eq #0, r0
   {
      //9876
      next_task(); //mov.l #schedule_running_task, r1, jmp @r1
   }
   else
      return;//979e
}